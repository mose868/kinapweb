const mongoose = require('mongoose');
const dotenv = require('dotenv');
const Mentorship = require('../models/Mentorship');
const sampleMentorships = require('../sample-data/mentorships');

dotenv.config();

async function populateMentorships() {
  try {
    // Connect to MongoDB
    await mongoose.connect(process.env.MONGODB_URI);
    console.log('Connected to MongoDB');

    // Clear existing mentorships to avoid conflicts
    await Mentorship.deleteMany({});
    console.log('Cleared existing mentorship programs');

    // Insert sample mentorships one by one to identify issues
    const createdMentorships = [];
    
    for (let i = 0; i < sampleMentorships.length; i++) {
      try {
        const mentorship = await Mentorship.create(sampleMentorships[i]);
        createdMentorships.push(mentorship);
        console.log(`‚úÖ Created: ${mentorship.mentor.name} - ${mentorship.title}`);
      } catch (error) {
        console.log(`‚ùå Failed to create: ${sampleMentorships[i].mentor.name} - ${sampleMentorships[i].title}`);
        console.log(`   Error: ${error.message}`);
      }
    }
    
    console.log(`\nüéâ Successfully created ${createdMentorships.length} mentorship programs`);

    // Display created mentorships with detailed information
    console.log('\nüìã MENTOR DIRECTORY:');
    console.log('='.repeat(80));
    
    createdMentorships.forEach((mentorship, index) => {
      const availabilityStatus = !mentorship.availability.isAvailable ? 'üî¥ UNAVAILABLE' : 
                                 mentorship.availability.status === 'Available' ? 'üü¢ AVAILABLE' : 
                                 mentorship.availability.status === 'Busy' ? 'üü° BUSY' : 
                                 mentorship.availability.status === 'Away' ? 'üü† AWAY' : 
                                 '‚ö™ OFFLINE';
      
      const instantStatus = mentorship.instantAvailability.enabled ? '‚ö° INSTANT' : 'üìÖ SCHEDULED';
      const priceDisplay = mentorship.pricing.isFree ? 'üÜì FREE' : `üí∞ KES ${mentorship.pricing.sessionRate}/session`;
      
      console.log(`\n${index + 1}. ${mentorship.mentor.name} (${mentorship.expertiseLevel})`);
      console.log(`   üìß ${mentorship.mentor.email} | üì± ${mentorship.mentor.phone}`);
      console.log(`   üè¢ ${mentorship.mentor.title} at ${mentorship.mentor.company}`);
      console.log(`   üéØ ${mentorship.category} | ‚≠ê ${mentorship.verification.badgeLevel} Badge`);
      console.log(`   ${availabilityStatus} | ${instantStatus} | ${priceDisplay}`);
      console.log(`   üë• ${mentorship.availability.currentMentees}/${mentorship.availability.maxMentees} mentees | ‚è±Ô∏è ${mentorship.availability.responseTime}`);
      console.log(`   üìä ${mentorship.statistics.totalSessions} sessions | ‚≠ê ${mentorship.ratings.overall} rating (${mentorship.ratings.totalRatings} reviews)`);
      console.log(`   üéì Featured: ${mentorship.isFeatured ? '‚≠ê YES' : 'No'} | üîç Verified: ${mentorship.verification.isVerified ? '‚úÖ YES' : '‚ùå No'}`);
      console.log(`   üõ†Ô∏è Skills: ${mentorship.skills.slice(0, 4).join(', ')}${mentorship.skills.length > 4 ? ` +${mentorship.skills.length - 4} more` : ''}`);
    });

    // Show comprehensive statistics
    console.log('\nüìä MENTORSHIP ECOSYSTEM ANALYTICS:');
    console.log('='.repeat(50));

    // Category distribution
    const categoryStats = await Mentorship.aggregate([
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
          avgSessionRate: { $avg: { $cond: [{ $eq: ['$pricing.isFree', false] }, '$pricing.sessionRate', null] } },
          availableMentors: { $sum: { $cond: [{ $eq: ['$availability.isAvailable', true] }, 1, 0] } },
          instantMentors: { $sum: { $cond: [{ $eq: ['$instantAvailability.enabled', true] }, 1, 0] } },
          totalSessions: { $sum: '$statistics.totalSessions' },
          avgRating: { $avg: '$ratings.overall' }
        }
      },
      { $sort: { count: -1 } }
    ]);

    console.log('\nüéØ Categories & Market Analysis:');
    categoryStats.forEach(stat => {
      console.log(`${stat._id}:`);
      console.log(`   üìà ${stat.count} mentors | üü¢ ${stat.availableMentors} available | ‚ö° ${stat.instantMentors} instant`);
      console.log(`   üí∞ Avg Rate: ${stat.avgSessionRate ? `KES ${Math.round(stat.avgSessionRate)}` : 'Varies'} | ‚≠ê Avg Rating: ${stat.avgRating ? stat.avgRating.toFixed(1) : 'N/A'}`);
      console.log(`   üìä Total Sessions: ${stat.totalSessions}`);
    });

    // Expertise level distribution
    const expertiseStats = await Mentorship.aggregate([
      {
        $group: {
          _id: '$expertiseLevel',
          count: { $sum: 1 },
          avgPrice: { $avg: { $cond: [{ $eq: ['$pricing.isFree', false] }, '$pricing.sessionRate', null] } },
          avgRating: { $avg: '$ratings.overall' }
        }
      },
      { $sort: { count: -1 } }
    ]);

    console.log('\nüèÜ Expertise Level Distribution:');
    expertiseStats.forEach(stat => {
      console.log(`${stat._id}: ${stat.count} mentors | Avg Price: ${stat.avgPrice ? `KES ${Math.round(stat.avgPrice)}` : 'Varies'} | Avg Rating: ${stat.avgRating ? stat.avgRating.toFixed(1) : 'N/A'}`);
    });

    // Availability analysis
    const availabilityStats = await Mentorship.aggregate([
      {
        $group: {
          _id: '$availability.status',
          count: { $sum: 1 }
        }
      },
      { $sort: { count: -1 } }
    ]);

    console.log('\nüö¶ Mentor Availability Status:');
    availabilityStats.forEach(stat => {
      const emoji = stat._id === 'Available' ? 'üü¢' : 
                   stat._id === 'Busy' ? 'üü°' : 
                   stat._id === 'Away' ? 'üü†' : 'üî¥';
      console.log(`${emoji} ${stat._id}: ${stat.count} mentors`);
    });

    // Pricing analysis
    const pricingStats = await Mentorship.aggregate([
      {
        $group: {
          _id: '$pricing.isFree',
          count: { $sum: 1 },
          avgPrice: { $avg: { $cond: [{ $eq: ['$pricing.isFree', false] }, '$pricing.sessionRate', null] } },
          minPrice: { $min: { $cond: [{ $eq: ['$pricing.isFree', false] }, '$pricing.sessionRate', null] } },
          maxPrice: { $max: { $cond: [{ $eq: ['$pricing.isFree', false] }, '$pricing.sessionRate', null] } }
        }
      }
    ]);

    console.log('\nüí∞ Pricing Structure:');
    pricingStats.forEach(stat => {
      if (stat._id) {
        console.log(`üÜì Free Mentors: ${stat.count}`);
      } else {
        console.log(`üí∞ Paid Mentors: ${stat.count}`);
        console.log(`   üíµ Price Range: KES ${stat.minPrice} - ${stat.maxPrice}`);
        console.log(`   üìä Average Rate: KES ${Math.round(stat.avgPrice)}`);
      }
    });

    // Instant availability analysis (Uber-like features)
    const instantStats = await Mentorship.aggregate([
      {
        $match: { 'instantAvailability.enabled': true }
      },
      {
        $group: {
          _id: null,
          totalInstantMentors: { $sum: 1 },
          availableInstantMentors: { $sum: { $cond: [{ $eq: ['$availability.isAvailable', true] }, 1, 0] } },
          maxConcurrentSessions: { $sum: '$instantAvailability.maxInstantRequests' },
          currentActiveSessions: { $sum: '$instantAvailability.currentInstantSessions' },
          avgResponseTime: { $avg: {
            $switch: {
              branches: [
                { case: { $eq: ['$availability.responseTime', 'Within 1 hour'] }, then: 30 },
                { case: { $eq: ['$availability.responseTime', 'Within 4 hours'] }, then: 120 },
                { case: { $eq: ['$availability.responseTime', 'Within 24 hours'] }, then: 720 }
              ],
              default: 1440
            }
          }}
        }
      }
    ]);

    console.log('\n‚ö° UBER-LIKE INSTANT MENTORSHIP CAPACITY:');
    if (instantStats.length > 0) {
      const stats = instantStats[0];
      console.log(`üöÄ Instant Mentors: ${stats.totalInstantMentors} total | ${stats.availableInstantMentors} available now`);
      console.log(`üéØ Capacity: ${stats.maxConcurrentSessions} max concurrent sessions | ${stats.currentActiveSessions} active now`);
      console.log(`‚è±Ô∏è Average Response Time: ${Math.round(stats.avgResponseTime)} minutes`);
      console.log(`üìà System Utilization: ${Math.round((stats.currentActiveSessions / stats.maxConcurrentSessions) * 100)}%`);
    }

    // Verification and quality metrics
    const qualityStats = await Mentorship.aggregate([
      {
        $group: {
          _id: null,
          totalMentors: { $sum: 1 },
          verifiedMentors: { $sum: { $cond: [{ $eq: ['$verification.isVerified', true] }, 1, 0] } },
          featuredMentors: { $sum: { $cond: [{ $eq: ['$isFeatured', true] }, 1, 0] } },
          avgOverallRating: { $avg: '$ratings.overall' },
          totalSessions: { $sum: '$statistics.totalSessions' },
          totalMentees: { $sum: '$statistics.totalMentees' },
          totalReviews: { $sum: '$ratings.totalRatings' }
        }
      }
    ]);

    console.log('\nüèÖ QUALITY & VERIFICATION METRICS:');
    if (qualityStats.length > 0) {
      const stats = qualityStats[0];
      console.log(`‚úÖ Verification Rate: ${Math.round((stats.verifiedMentors / stats.totalMentors) * 100)}% (${stats.verifiedMentors}/${stats.totalMentors})`);
      console.log(`‚≠ê Featured Mentors: ${stats.featuredMentors} (${Math.round((stats.featuredMentors / stats.totalMentors) * 100)}%)`);
      console.log(`üìä Platform Rating: ${stats.avgOverallRating.toFixed(1)}‚≠ê overall`);
      console.log(`üéØ Total Impact: ${stats.totalSessions} sessions | ${stats.totalMentees} mentees helped | ${stats.totalReviews} reviews`);
    }

    // Geographic distribution
    const locationStats = await Mentorship.aggregate([
      {
        $group: {
          _id: '$location.city',
          count: { $sum: 1 },
          availableCount: { $sum: { $cond: [{ $eq: ['$availability.isAvailable', true] }, 1, 0] } },
          locationEnabled: { $sum: { $cond: [{ $eq: ['$location.isLocationEnabled', true] }, 1, 0] } }
        }
      },
      { $sort: { count: -1 } }
    ]);

    console.log('\nüìç Geographic Distribution:');
    locationStats.forEach(stat => {
      if (stat._id) {
        console.log(`${stat._id}: ${stat.count} mentors | ${stat.availableCount} available | ${stat.locationEnabled} location-enabled`);
      }
    });

    // Most popular mentors (for Uber-like matching)
    const popularMentors = createdMentorships
      .filter(m => m.availability.isAvailable)
      .sort((a, b) => (b.ratings.overall * b.ratings.totalRatings) - (a.ratings.overall * a.ratings.totalRatings))
      .slice(0, 5);

    console.log('\nüî• TOP-RATED AVAILABLE MENTORS (For Instant Matching):');
    popularMentors.forEach((mentor, index) => {
      console.log(`${index + 1}. ${mentor.mentor.name} - ${mentor.category}`);
      console.log(`   ‚≠ê ${mentor.ratings.overall} rating (${mentor.ratings.totalRatings} reviews) | ${mentor.statistics.totalSessions} sessions`);
      console.log(`   üí∞ ${mentor.pricing.isFree ? 'FREE' : `KES ${mentor.pricing.sessionRate}/session`} | ‚ö° ${mentor.instantAvailability.enabled ? 'Instant Available' : 'Scheduled Only'}`);
    });

    // Uber-like availability simulation
    const uberLikeAvailable = createdMentorships.filter(m => 
      m.availability.isAvailable && 
      m.instantAvailability.enabled &&
      m.availability.currentMentees < m.availability.maxMentees
    );

    console.log('\nüöó UBER-LIKE INSTANT AVAILABILITY:');
    console.log(`üü¢ ${uberLikeAvailable.length} mentors available for instant requests right now!`);
    
    if (uberLikeAvailable.length > 0) {
      console.log('\nüì≤ Ready for instant mentoring:');
      uberLikeAvailable.forEach(mentor => {
        const responseEmoji = mentor.availability.responseTime === 'Within 1 hour' ? 'üöÄ' : 
                            mentor.availability.responseTime === 'Within 4 hours' ? '‚ö°' : 'üìÖ';
        console.log(`   ${responseEmoji} ${mentor.mentor.name} (${mentor.category}) - ${mentor.availability.responseTime}`);
      });
    }

    // System readiness summary
    console.log('\nüéØ MENTORSHIP PLATFORM READINESS:');
    console.log('='.repeat(40));
    console.log(`‚úÖ Total Mentors: ${createdMentorships.length}`);
    console.log(`üü¢ Available Now: ${createdMentorships.filter(m => m.availability.isAvailable).length}`);
    console.log(`‚ö° Instant Ready: ${uberLikeAvailable.length}`);
    console.log(`üÜì Free Options: ${createdMentorships.filter(m => m.pricing.isFree).length}`);
    console.log(`‚úÖ Verified: ${createdMentorships.filter(m => m.verification.isVerified).length}`);
    console.log(`‚≠ê Featured: ${createdMentorships.filter(m => m.isFeatured).length}`);
    console.log(`üìä Average Rating: ${(createdMentorships.reduce((sum, m) => sum + m.ratings.overall, 0) / createdMentorships.length).toFixed(1)}‚≠ê`);
    
    console.log('\nüöÄ The Uber-like mentorship matching system is ready!');
    console.log('   üì± Mentees can now request instant help');
    console.log('   üîî Mentors will receive real-time notifications');
    console.log('   ‚ö° Average response time: 1-4 hours');
    console.log('   üéØ Multiple categories and expertise levels available');

    mongoose.connection.close();
    console.log('\n‚úÖ Database connection closed');
    console.log('üéâ Mentorship ecosystem successfully populated!');
    
  } catch (error) {
    console.error('‚ùå Error populating mentorship programs:', error);
    process.exit(1);
  }
}

// Run the script
populateMentorships(); 